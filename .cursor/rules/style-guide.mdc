---
description: TypeScript Style Guide - AI-Ready Code Standards
globs: "**/*.{ts,tsx,js,jsx}"
alwaysApply: true
---

# TypeScript Style Guide

This guide defines how we write TypeScript. It optimizes for **correctness**, **clarity**, and **maintainability**. The linter (Ultracite/Biome) enforces most rules automatically—run `npm exec -- ultracite fix` before committing.

---

## Philosophy

1. **Validate at the edges, trust internally** — Use runtime validation (Zod, etc.) at trust boundaries (API responses, user input, env vars). Once validated, trust the refined types throughout the codebase. No defensive re-checking.

2. **Explicit over implicit** — Make types, intentions, and control flow obvious. Avoid magic.

3. **Immutable by default** — Use `const`, `readonly`, and return new values instead of mutating.

4. **Simple over clever** — Write code a newcomer can understand. Avoid premature abstraction.

5. **Let the type system work** — Design types that make invalid states unrepresentable. Use discriminated unions and exhaustive checks.

---

## Type System

### Use `unknown`, Never `any`

```typescript
// Bad
function parse(data: any) { ... }

// Good
function parse(data: unknown) {
  if (!isValidData(data)) throw new Error('Invalid data');
  // data is now narrowed
}
```

### Discriminated Unions with Exhaustive Checks

Model state explicitly. Use a discriminant property and handle all cases.

```typescript
type Result<T, E> =
  | { ok: true; value: T }
  | { ok: false; error: E };

function handle(result: Result<User, string>) {
  switch (result.ok) {
    case true:
      return result.value;
    case false:
      throw new Error(result.error);
    default:
      const _exhaustive: never = result;
      throw new Error('Unhandled case');
  }
}
```

### Use `satisfies` for Validated Inference

Use `satisfies` when you want type validation without widening the inferred type.

```typescript
// Bad — loses literal types
const routes: Record<string, Route> = {
  '/home': { path: '/home' },
};

// Good — validates shape, keeps literals
const routes = {
  '/home': { path: '/home' },
} satisfies Record<string, Route>;
```

Combine with `as const` for maximum precision:

```typescript
const config = {
  timeout: 5000,
  retries: 3,
} as const satisfies Config;
```

### Prefer `interface` for Object Types

```typescript
// Preferred
interface User {
  id: string;
  name: string;
}

// Use type for unions, intersections, mapped types
type Status = 'pending' | 'active' | 'inactive';
```

### Derive Types from Source of Truth

Don't copy-paste type definitions. Derive them.

```typescript
// From values
const STATUSES = ['pending', 'active', 'inactive'] as const;
type Status = (typeof STATUSES)[number];

// From objects
const config = { timeout: 5000 } as const;
type Config = typeof config;

// From functions
type ParseResult = ReturnType<typeof parse>;
type Options = Parameters<typeof createClient>[0];
```

### Branded Types for Semantic Primitives

```typescript
type UserId = string & { readonly __brand: 'UserId' };
type PostId = string & { readonly __brand: 'PostId' };

function createUserId(id: string): UserId {
  return id as UserId;
}
```

### No Type Assertions or Non-Null Assertions

Avoid `as` and `!`. Fix the types or add runtime checks.

```typescript
// Bad
const user = data as User;
const name = user!.name;

// Good
if (!isUser(data)) throw new Error('Invalid user');
const name = user.name;
```

---

## No Enums

Enums are banned. Use `as const` objects with derived union types.

```typescript
// Bad
enum Status {
  Pending = 'pending',
  Active = 'active',
}

// Good
const Status = {
  Pending: 'pending',
  Active: 'active',
} as const;

type Status = (typeof Status)[keyof typeof Status];
```

---

## Immutability

### Default to `const` and `readonly`

```typescript
const count = 0;
let mutable = 0; // Only when reassignment is required

const items: readonly string[] = ['a', 'b'];
const config: Readonly<Config> = { ... };

class Service {
  readonly client: Client;
}
```

### Never Mutate Parameters

```typescript
// Bad
function process(items: Item[]) {
  items.push(newItem);
}

// Good
function process(items: readonly Item[]): Item[] {
  return [...items, newItem];
}
```

### Avoid Spread in Loops

```typescript
// Bad — O(n²)
const result = items.reduce((acc, item) => [...acc, transform(item)], []);

// Good
const result = items.map(transform);
```

---

## Code Organization

### YAGNI — You Aren't Gonna Need It

- Start with concrete implementations
- Extract abstractions only when patterns emerge (3+ usages)
- Don't design for hypothetical future requirements
- Delete unused code; don't comment it out

### Early Returns

```typescript
// Bad
function process(user: User | null) {
  if (user) {
    if (user.isActive) {
      return doWork(user);
    }
  }
  return null;
}

// Good
function process(user: User | null) {
  if (!user) return null;
  if (!user.isActive) return null;
  return doWork(user);
}
```

### Keep Functions Focused

```typescript
// Bad
if (user.role === 'admin' && user.isActive && !user.isSuspended) { ... }

// Good
const canPerformAction = user.role === 'admin' && user.isActive && !user.isSuspended;
if (canPerformAction) { ... }
```

---

## Error Handling

### Throw Only Error Objects

```typescript
// Bad
throw 'Something went wrong';

// Good
throw new Error('Something went wrong');
```

### Validate at Boundaries

```typescript
import { z } from 'zod';

const UserSchema = z.object({
  id: z.string(),
  email: z.string().email(),
});

type User = z.infer<typeof UserSchema>;

async function fetchUser(id: string): Promise<User> {
  const response = await fetch(`/api/users/${id}`);
  const data = await response.json();
  return UserSchema.parse(data);
}
```

### Consider Result Types

```typescript
type Result<T, E = Error> =
  | { ok: true; value: T }
  | { ok: false; error: E };
```

---

## Imports and Exports

- **Named exports only** — No default exports
- **Type-only imports** — Use `import type` for types
- **No barrel files** — Import from the source
- **No namespace imports** — No `import * as foo`

```typescript
import type { User } from './types';
import { validateUser } from './validation';
```

---

## Functions

- **Arrow functions** for callbacks
- **No `Function` type** — Define specific signatures
- **Rest parameters** over `arguments`
- **Default parameters last**

```typescript
// Good
items.map((item) => transform(item));

function execute(callback: (result: Result) => void) { ... }

function log(...args: unknown[]) { ... }

function create(name: string, options = {}) { ... }
```

---

## Classes

- **Object literals for singletons** — Don't wrap in classes
- **Readonly properties by default** — Enforced by linter
- **No parameter properties** — No `constructor(private x)`

```typescript
// Good
const validator = {
  validateEmail(email: string) { ... },
};

class Service {
  readonly client: Client;

  constructor(client: Client) {
    this.client = client;
  }
}
```

---

## Naming Conventions

| Element | Convention | Example |
|---------|------------|---------|
| Files | kebab-case | `user-service.ts` |
| Variables, functions | camelCase | `getUserById` |
| Constants | CONSTANT_CASE | `MAX_RETRIES` |
| Types, interfaces, classes | PascalCase | `UserService` |
| Type parameters | Single uppercase or PascalCase | `T`, `TResult` |

---

## Testing

- Write assertions inside `it()` or `test()` blocks
- Use `async`/`await`, not done callbacks
- Never commit `.only` or `.skip`
- Keep suites flat

---

## Linter Reference

Key enforced rules (Ultracite/Biome):

| Rule | Enforcement |
|------|-------------|
| `noExplicitAny` | No `any` type |
| `noNonNullAssertion` | No `!` assertions |
| `noForEach` | Use `for...of` |
| `noEnum` | No enums |
| `noVar` | No `var` |
| `useConst` | Prefer `const` |
| `useArrowFunction` | Arrow functions |
| `useImportType` | Type-only imports |
| `noBarrelFile` | No re-export index files |
| `noNamespaceImport` | No `import *` |
| `useReadonlyClassProperties` | Readonly class props |
| `noParameterProperties` | No `constructor(private x)` |
| `noAccumulatingSpread` | No spread in loops |
| `useFilenamingConvention` | kebab-case files |

Run `npm exec -- ultracite fix` to auto-fix most issues.
