---
description: Cria Code Standards
globs: "**/*.{ts,tsx,js,jsx}"
alwaysApply: false
---

# Cria Code Standards

## Quick Reference

```bash
npm exec -- ultracite fix     # format and fix
npm exec -- ultracite check   # check issues
npm exec -- ultracite doctor  # diagnose setup
```

**Commits**: Use [Conventional Commits](https://www.conventionalcommits.org/) — `type(scope): subject`

---

## TypeScript

**Type safety at boundaries, trust internally:**
- Use `unknown` at trust boundaries (I/O, JSON, env); never `any`. Narrow immediately.
- Validate external inputs once, then trust refined types downstream—no defensive re-checking inside trusted layers.
- Don't accept `Record<string, unknown>` or `object` when you can define a concrete shape.

**Prefer the type system over runtime checks:**
- Use explicit types for parameters and return values when they enhance clarity.
- Leverage TypeScript's type narrowing instead of type assertions.
- Model state with discriminated unions; handle exhaustively via `switch` + `assertNever`.
- Avoid type assertions and `!`—restructure so types prove safety.
- Use `as const` for literals, `satisfies` for object shapes without widening.
- Use meaningful variable names instead of magic numbers—extract constants with descriptive names.

**Immutability by default:**
- `const` bindings, `readonly` arrays/tuples, `Readonly<T>`.
- Avoid mutating inputs; create copies instead (but avoid repeated spreads in hot loops).

## Cria-Specific

- Treat Cria as a closed system: strict contracts over defensive runtime checks.
- Enforce constraints with types + tests; no runtime guards for trusted internal data.
- No silent failures—if it fails, it must throw.
- No implicit context propagation; require explicit parameters.
- Use SDK types directly; don't invent wrapper interfaces.
- Cache pinning must be explicit: `pin({ id, version })` directly.

## Patterns

**Functions:**
- Pure helpers with effects at the edges (I/O, logging).
- Use array transforms (`map`, `filter`, `reduce`, `flatMap`) when clearer than imperative loops.
- Arrow functions for callbacks and short functions.
- Early returns over nested conditionals.
- Prefer simple conditionals over nested ternary operators.
- Extract complex conditions into named booleans.
- Keep functions focused; reasonable cognitive complexity.
- Group related code together and separate concerns.

**Modern JS/TS:**
- `for...of` over `.forEach()` and indexed loops.
- `?.` and `??` for safe property access.
- Template literals over concatenation.
- Destructuring without unnecessary renames.
- `const` default, `let` when needed, never `var`.

**Async:**
- Always `await` promises—don't forget return values.
- `async/await` over promise chains.
- Handle errors appropriately in async code with try-catch.
- No async functions as Promise executors.

## Error Handling

- Remove `console.log`, `debugger`, `alert` from production.
- Throw `Error` objects with descriptive messages, not strings.
- Use `try-catch` meaningfully—don't catch just to rethrow.
- Prefer early returns over nested conditionals for error cases.

## Security

- `rel="noopener"` on `target="_blank"` links.
- Avoid `dangerouslySetInnerHTML`, `eval()`, direct `document.cookie` assignment.
- Validate and sanitize user input.

## Performance

- No spread in loop accumulators.
- Top-level regex literals, not created in loops.
- Specific imports over namespace imports.
- No barrel files.

## Testing

- Assertions inside `it()` / `test()` blocks.
- `async/await` over done callbacks.
- No `.only` or `.skip` in committed code.
- Flat test suites—avoid excessive `describe` nesting.

---

## Focus Areas

Biome handles formatting. Focus on:

1. **Business logic** — correctness of algorithms
2. **Naming** — descriptive functions, variables, types
3. **Architecture** — component structure, data flow, API design
4. **Edge cases** — boundary conditions, error states
5. **UX** — accessibility, performance, usability
6. **Documentation** — comments for complex logic only
